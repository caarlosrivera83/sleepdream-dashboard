<!doctype html><meta charset="utf-8">
<title>SleepDream Dashboard</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
  body{font:14px/1.4 system-ui,Segoe UI,Roboto,Arial;padding:16px;max-width:1100px;margin:auto}
  h1{margin:0 0 8px}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:16px}
  .full{grid-column:1 / -1}
  .card{border:1px solid #ddd;border-radius:12px;padding:12px}
  .muted{color:#555}
  select,button{padding:6px 10px;border-radius:8px;border:1px solid #ccc}
  table{width:100%;border-collapse:collapse}
  th,td{border:1px solid #e5e5e5;padding:6px;text-align:left}
  th{background:#fafafa}
</style>

<h1>SleepDream – Panel</h1>
<div class="muted" id="last">Cargando…</div>

<div style="margin:10px 0; display:flex; gap:10px; align-items:center; flex-wrap:wrap">
  <label>Dispositivo:</label>
  <select id="deviceSel"><option value="">Todos</option></select>
  <label style="margin-left:10px;">Ventana:</label>
  <select id="winSel">
    <option value="0.25" selected>15 min</option>
    <option value="1">1 h</option>
    <option value="2">2 h</option>
    <option value="6">6 h</option>
    <option value="12">12 h</option>
    <option value="24">24 h</option>
  </select>
  <button id="refreshBtn">Actualizar</button>
</div>

<div class="row">
  <div class="card"><canvas id="ruido"></canvas></div>
  <div class="card"><canvas id="pulso"></canvas></div>
</div>

<div class="row" style="margin-top:16px;">
  <div class="card full">
    <h3 style="margin-top:0">Últimos registros</h3>
    <table id="tbl">
      <thead></thead>
      <tbody></tbody>
    </table>
  </div>

  <div class="card full">
    <h3 style="margin-top:0">Eventos de ruido (umbral superado)</h3>
    <table id="tblev">
      <thead><tr><th>Inicio</th><th>Fin</th><th>Pico dB</th><th>Umbral</th><th>Muestras</th></tr></thead>
      <tbody></tbody>
    </table>
    <div class="muted">Requiere la vista <code>ruido_eventos</code> en la BD.</div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<script>
/* ======= CONFIG ======= */
const PROJECT = "tqxiecgruhcnpuvciypa";  // tu project ref
const ANON    = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRxeGllY2dydWhjbnB1dmNpeXBhIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjA0NTkzODQsImV4cCI6MjA3NjAzNTM4NH0.FOdMzy8O2mdTD0ObEcy34Jllue5lzMsOGqFIs6QFlLU";
const REST = `https://${PROJECT}.supabase.co/rest/v1`;
const H = { apikey: ANON, Authorization: "Bearer " + ANON };

/* ======= UI refs ======= */
const deviceSel = document.getElementById('deviceSel');
const winSel    = document.getElementById('winSel');
const lastLbl   = document.getElementById('last');
document.getElementById('refreshBtn').onclick = () => loadAll();

/* ======= Utils ======= */
function isoHoursAgo(h){ return new Date(Date.now() - h*3600e3).toISOString(); }
function fmtTime(s){ return new Date(s).toLocaleTimeString(); }
function fmtDate(s){ return new Date(s).toLocaleString(); }

async function fetchJSON(url){
  const r = await fetch(url, { headers: H });
  if(!r.ok) throw new Error(await r.text());
  return r.json();
}

/* ======= Downsampling ======= */
const MAX_POINTS = 800;
function downsampleEveryN(arr, n) {
  if (n <= 1) return arr;
  const out = [];
  for (let i = 0; i < arr.length; i += n) out.push(arr[i]);
  return out;
}
function maybeThin(labels, seriesList) {
  const L = labels.length;
  if (L <= MAX_POINTS) return { labels, seriesList };
  const n = Math.ceil(L / MAX_POINTS);
  const labels2 = downsampleEveryN(labels, n);
  const thinned = seriesList.map(s => downsampleEveryN(s, n));
  return { labels: labels2, seriesList: thinned };
}

/* ======= Data loaders ======= */
async function loadDevices(){
  const since = isoHoursAgo(24);
  const url = `${REST}/lecturas?select=dispositivo_id&ts=gte.${since}&order=dispositivo_id.asc`;
  const rows = await fetchJSON(url);
  const ids = [...new Set(rows.map(r => r.dispositivo_id).filter(Boolean))];
  deviceSel.innerHTML = '<option value="">Todos</option>' + ids.map(id =>
    `<option value="${id}">${id.slice(0,8)}…</option>`).join('');
}

async function loadLecturas(){
  const hours = parseFloat(winSel.value);
  const since = isoHoursAgo(hours);
  // seguimos trayendo spo2_pct por si más adelante la vuelves a usar en la tabla
  let url = `${REST}/lecturas?select=ts,dispositivo_id,ruido_db,ruido_peak_db,limit_db,over_limit,pulso_bpm,spo2_pct&ts=gte.${since}&order=ts.asc`;
  const dev = deviceSel.value.trim();
  if (dev) url += `&dispositivo_id=eq.${dev}`;
  return fetchJSON(url);
}

async function loadEventos(){
  const hours = parseFloat(winSel.value);
  const since = isoHoursAgo(hours);
  let url = `${REST}/ruido_eventos?select=start_ts,end_ts,peak_db,limit_db,samples&start_ts=gte.${since}&order=start_ts.desc`;
  const dev = deviceSel.value.trim();
  if (dev) url += `&dispositivo_id=eq.${dev}`;
  try { return await fetchJSON(url); }
  catch { return []; }
}

/* ======= Charts ======= */
let ruidoChart, pulsoChart;
function makeLine(ctx, labels, datasets, yTitle){
  return new Chart(ctx, {
    type: 'line',
    data: { labels, datasets },
    options: {
      responsive: true, animation: false,
      interaction: { mode: 'index', intersect: false },
      scales: {
        x: { ticks: { maxRotation: 0 } },
        y: { title: { display: true, text: yTitle } }
      },
      plugins: { legend: { labels: { boxWidth: 12 } } }
    }
  });
}

/* ======= Render ======= */
function renderLecturas(rows){
  // Series base
  const labels = rows.map(r => fmtTime(r.ts));
  const ruido  = rows.map(r => r.ruido_db ?? null);
  const peak   = rows.map(r => r.ruido_peak_db ?? null);

  // Umbral: si viene null, repetimos el último conocido
  const limit = [];
  let lastLim = null;
  for (const r of rows){ lastLim = (r.limit_db ?? lastLim ?? null); limit.push(lastLim); }

  const bpm   = rows.map(r => r.pulso_bpm ?? null);
  const spo2  = rows.map(r => r.spo2_pct ?? null); // por si lo quieres mostrar luego en la tabla

  // Submuestreo si hay demasiados puntos
  let { labels: L2, seriesList } = maybeThin(labels, [ruido, peak, limit, bpm, spo2]);
  const [rruido, rpeak, rlimit, rbpm, rspo2] = seriesList;

  // Ruido
  if (!ruidoChart) {
    ruidoChart = makeLine(
      document.getElementById('ruido'),
      L2,
      [
        { label: 'Ruido (dB)', data: rruido, tension: 0.2 },
        { label: 'Pico (dB)',  data: rpeak,  tension: 0.2 },
        { label: 'Umbral (dB)',data: rlimit, tension: 0, borderDash: [6,6] }
      ],
      'dB'
    );
  } else {
    Object.assign(ruidoChart.data, { labels: L2, datasets: [
      { label: 'Ruido (dB)', data: rruido, tension: 0.2 },
      { label: 'Pico (dB)',  data: rpeak,  tension: 0.2 },
      { label: 'Umbral (dB)',data: rlimit, tension: 0, borderDash: [6,6] }
    ]});
    ruidoChart.update();
  }

  // Pulso
  if (!pulsoChart) {
    pulsoChart = makeLine(
      document.getElementById('pulso'),
      L2,
      [{ label: 'BPM', data: rbpm, tension: 0.2 }],
      'BPM'
    );
  } else {
    Object.assign(pulsoChart.data, { labels: L2, datasets: [{ label: 'BPM', data: rbpm, tension: 0.2 }]});
    pulsoChart.update();
  }

  // -------- Tabla dinámica (oculta columnas vacías) --------
  const last = rows.slice(-50).reverse();

  // Definición de columnas potenciales
  const COLS = [
    { key: 'ts',            label: 'Hora',        fmt: r => fmtDate(r.ts), always: true },
    { key: 'ruido_db',      label: 'Ruido dB',    fmt: r => r.ruido_db ?? '' },
    { key: 'ruido_peak_db', label: 'Pico dB',     fmt: r => r.ruido_peak_db ?? '' },
    { key: 'limit_db',      label: 'Umbral',      fmt: r => r.limit_db ?? '' },
    { key: 'over_limit',    label: 'Over',        fmt: r => (r.over_limit===true?'Sí':(r.over_limit===false?'No':'')) },
    { key: 'pulso_bpm',     label: 'BPM',         fmt: r => r.pulso_bpm ?? '' },
    { key: 'spo2_pct',      label: 'SpO₂ %',      fmt: r => r.spo2_pct ?? '' }
  ];

  // Detecta qué columnas tienen al menos un valor (excepto 'ts' que siempre va)
  const hasValue = (rows, key) => {
    if (key === 'over_limit') return rows.some(r => r.over_limit === true || r.over_limit === false);
    return rows.some(r => r[key] !== null && r[key] !== undefined && r[key] !== '');
  };
  const activeCols = COLS.filter(c => c.always || hasValue(last, c.key));

  // Render header
  const thead = document.querySelector('#tbl thead');
  thead.innerHTML = '<tr>' + activeCols.map(c => `<th>${c.label}</th>`).join('') + '</tr>';

  // Render body
  const tb = document.querySelector('#tbl tbody');
  tb.innerHTML = last.map(r =>
    '<tr>' + activeCols.map(c => `<td>${c.fmt(r)}</td>`).join('') + '</tr>'
  ).join('');
}

function renderEventos(rows){
  const tb = document.querySelector('#tblev tbody');
  tb.innerHTML = rows.map(r => `
    <tr>
      <td>${fmtDate(r.start_ts)}</td>
      <td>${fmtDate(r.end_ts)}</td>
      <td>${r.peak_db?.toFixed ? r.peak_db.toFixed(1) : (r.peak_db ?? '')}</td>
      <td>${r.limit_db ?? ''}</td>
      <td>${r.samples ?? ''}</td>
    </tr>
  `).join('');
}

/* ======= Orquestación ======= */
async function loadAll(){
  lastLbl.textContent = 'Actualizando…';
  const [lecturas, eventos] = await Promise.all([loadLecturas(), loadEventos()]);
  renderLecturas(lecturas);
  renderEventos(eventos);
  lastLbl.textContent = 'Última actualización: ' + new Date().toLocaleString();
}

(async () => {
  try {
    await loadDevices();
    await loadAll();
    setInterval(loadAll, 5000); // auto-refresh 5 s
  } catch(e){
    document.body.insertAdjacentHTML('beforeend', `<pre style="color:#b00">Error: ${e.message}</pre>`);
  }
})();
</script>
